## Object
* 创建实例的两种方式：1.`new`操作符和构造函数；2.对象字面量。
* 对象字面量表示法中，属性名可以是字符串或数值，数值属性会自动转换为字符串。
* 存取属性的方式包括点语法和中括号形式，中括号内要使用属性名的字符串形式。

## Array
* JS中的数组与其他语言的数组的区别：1.可以存储任意类型的数据；2.动态增长。
* 创建数组实例：1.使用`new`操作符和构造函数；2.省略`new`操作符；3.使用构造函数时可以传入数值，表示创建的数组大小；4.传入要保存的元素；5.数组字面量。
* 创建数组的静态方法（ES6新增）：
	* `Array.from()`：用于将类数组结构转换为数组实例。第一个参数为类数组对象，即任何可以迭代的结构或有必要属性（`length`和可索引元素）的结构。第二个参数是可选的映射函数参数，直接增强新数组的值。
	* `Array.of()`：用于将一组参数转换为数组实例。
* 使用一串逗号隔开创建的数组字面量可以创建数组空位，ES6将空位视为值为`undefined`的元素。
* 数组的`length`属性不是只读的，修改`length`属性可以删除或添加元素，新添加的元素以`undefined`填充。
* `Array.isArray()`：确定一个值是否为数组。不用`instanceof`检测的原因是有可能涉及两个不同的全局执行上下文，因此会有两个不同版本的`Array`构造函数。
* 迭代器方法：
	* `keys()`：返回数组索引的迭代器。
	* `values()`：返回数组元素的迭代器。
	* `entries()`：返回索引/值对的迭代器。
* 迭代方法：接收一个以数组元素为参数运行的函数，以及可选的作为函数运行上下文的作用域对象。函数接收数组元素、元素索引和数组本身三个参数。
	* `every()`：函数对数组每一项都会返回`true`，才返回`true`，否则返回`false`。
	* `some()`：函数对数组任意一项返回`true`，就返回`true`，否则返回`false`。
	* `map()`：返回由每次函数调用的结果构成的数组。原始数组不改变。
	* `filter()`：返回函数返回`true`的元素构成的数组。
	* `forEach()`：对数组每项元素都执行函数，没有返回值。原始数组不改变。
* `reduce()`：迭代数组所有项，返回一个构建的最终返回值。接收一个函数，以及可选的归并起点的初始值。函数接收4个参数：上一个归并值、当前元素、当前元素的索引和数组本身。
* `fill()`：填充数组，向一个已有的数组中插入全部或部分相同的值。第二个参数是可选的开始填充的索引。
* `valueOf()`返回数组本身。`toString()`对数组的每个值调用其`toString()`方法，将字符串拼接为一个逗号分隔的字符串。
* `join()`：接收一个字符串分隔符，默认为逗号，返回包含所有项的字符串。
* 常用数组方法：
	* `push()`：在数组末尾添加任意多元素，返回数组最新长度。
	* `pop()`：删除数组最后一项，返回被删除的元素。
	* `shift()`：删除数组的第一项，返回被删除的元素。
	* `unshift()`：在数组开头添加任意多元素，返回数组最新长度。
	* `reverse()`：将数组元素反向排列。
	* `sort()`：默认按照转换后的字符串升序排列。
		* 可以接收一个比较函数，该比较函数接收两个参数，如果第一个排在第二个前面，返回负值，相等返回0，否则返回正值。
		* 如果数组元素为数值，或`valueOf()`返回数值的对象（`Date`对象），可以简单写成参数相减的操作。
	* `concat()`：用于合并数组。可以传入一个或多个数组或非数组，返回添加了所有元素的新数组。`[Symbol.isConcatSpreadable]`设置为`true`可以强制打平类数组对象，`false`可以强制不打平数组。
	* `slice()`：用于创建一个包含原有数组中一个或多个元素的新数组。接收一个开始索引，可选的结束索引。操作不影响原始数组。
	* `splice()`：可以对数组元素进行删除、插入和替换。第一个参数为开始元素的位置，第二个参数为要删除的元素数量，从第三个参数开始为要插入的任意多个元素。原始数组被原地修改，方法返回从数组中被删除的元素。
* 搜索元素和位置：
	* `indexOf()`：从数组开头搜索，返回查找的元素索引值，没找到返回-1。使用全等比较。
	* `includes()`：从数组开头搜索，返回布尔值，表示是否至少找到一个匹配的项。使用全等比较。
	* `lastIndexOf()`：从数组结尾搜索，返回查找的元素索引值，没找到返回-1。使用全等比较。
	* `find()`和`findeIndex()`：接收一个断言函数，返回第一个匹配元素或其索引值。函数接收元素、索引和数组本身，返回布尔值，表示是否匹配。

## Map
* `Map`是ES6新增的一种集合类型，用于存储键值对，维护键值对的插入顺序。键可以使用任何数据类型，有别于`Object`只能使用数值、字符串或符号。采用严格对象相等的标准。
* 使用`new`关键字和构造函数创建空映射，也可以传入一个可迭代对象，需要包含键值对数组。
* 常用方法：
	* `set(key, value)`：添加键值对。可以连用。
	* `get(key)`：获取指定`key`对应的`value`。
	* `has(key)`；查询映射中是否含有`key`，返回布尔值。
	* `size`属性：键值对数量。
	* `delete()`、`clear()`：删除一个或所有键值对。
	* `keys()`、`values()`：返回以插入顺序生成键或值的迭代器。
	* `entries()`：返回以插入顺序生成键值对的迭代器，是`Map`的默认迭代器，可以直接对`Map`实例使用扩展操作，将其转换为数组。
* `Object`和`Map`的选择：
	* 两种结构存储单个键值对占用的内存都会随键的数量线性增加。相同的内存大小下，`Map`比`Object`存储更多的键值对。
	* 插入性能相当。大量插入操作下，`Map`性能更佳。
	* 查找速度相当。大量查找操作下，`Object`性能更佳。
	* 删除性能。大量删除操作下，`Map`性能更佳。`Map`的删除比插入和查找更快。

## WeakMap
* `Weak`描述的是垃圾回收程序对待`WeakMap`中键的方式。键不属于正式的引用，不会组织垃圾回收。当没有指向某个键的其他引用，这个键值对就会被垃圾回收。
* `WeakMap`的键只能是`Object`或继承自`Object`的类型。
* `WeakMap`没有迭代键值对的能力，因为键值对随时可能被销毁。
* 使用场景：
	* 实现私有变量。以对象实例为键，以私有成员的字典为值。进一步地，为了防止外部代码的访问，可以使用闭包将`WeakMap`包装起来。
	* 保存关联元数据。使用`WeakMap`保存DOM节点的引用，在DOM节点删除后，不会阻止释放内存。

## Set
* ES6新增的集合类型，用于保存不重复的数组，维护值的插入顺序。
* `add()`：增加值。其余操作与Map相似。
* `keys()`和`values()`返回的都是以插入顺序生成值的迭代器。`values()`是默认迭代器，可以直接对`Set`实例使用扩展操作，将其转换为数组。
* `entries()`：返回以插入顺序产生包含值的重复出现的数组。

## WeakSet
* `Weak`描述的是垃圾回收程序对待`WeakSet`中值的方式。
* `WeakSet`的值只能是`Object`或继承自`Object`的类型。
* `WeakSet`没有迭代其值的能力，因为值随时可能被销毁。
* 使用场景：给DOM节点打标签，在删除DOM节点后，立即释放其内存。