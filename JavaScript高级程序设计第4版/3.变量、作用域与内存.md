## 原始值与引用值
* 6种原始值：`undefined`、`null`、`Boolean`、`Number`、`String`和`Symbol`，按值访问。
* 引用值：保存在内存中的对象，由多个值构成，按引用访问。操作对象实际上是操作对该对象的引用而非对象本身。
### 动态属性
* 原始值不具有属性，引用值可以动态添加属性。
* 原始类型的初始化可以使用原始字面量形式，也可以使用`new`关键字创建一个`Object`类型的实例，行为类似原始值，可以添加动态属性。

### 复制值
* 原始值在通过变量复制时，会被复制到新变量的位置，两个变量完全独立。
* 引用值在复制时，存储在变量中的值（指针）会被复制到新变量所在的位置，两个变量指向堆内存中同一个对象实例。

### 按值传参
* 所有函数的参数都是==按值传递==，也就是函数外的值会被复制到函数内部的参数。
* 无论传递的参数是原始值还是引用值，传递方式都是按值传递。因为引用值复制后，函数内的参数同样可以通过引用访问对象。

### 确定类型
* `instanceof`操作符：用于判断引用值是否是给定引用类型的实例。
* 所有引用值都是`Object`的实例。
* 用`instanceof`检测原始值，始终返回`false`，因为原始值不是对象。

## 执行上下文
* 变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。
* 每个上下文关联一个==变量对象==，这个对象上保存了这个上下文中定义的所有变量和函数。
* 执行上下文分为全局上下文、函数上下文和块级上下文。
	* 全局上下文：最外层的执行上下文，在浏览器里指`window`对象，在应用程序退出前被销毁。
	* 函数或块级上下文：当代码执行流进入函数/代码块时，向上下文栈中压入一个新的上下文。
* 作用域链：决定各级上下文中的代码在访问变量和函数时的顺序，用于搜索变量和函数。作用域链最前端是代码正在执行的上下文的变量对象，下一个变量对象逐级类推至全局上下文。标识符解析沿作用域链逐级向外部上下文搜索，局部上下文不仅可以访问自己作用域内的变量，也可以访问任何包含上下文乃至全局上下文的变量。

## 垃圾回收机制
* JavaScript使用垃圾回收机制，执行环境在代码执行时自动管理内存，也就是说开发人员不需要关注内存的分配和回收。垃圾回收是周期性的。
* 垃圾回收的标记策略：标记清理和引用计数。
	* 标记清理：最常用的垃圾回收算法。给当前不使用的值加上标记，随后垃圾回收程序销毁所有标记的值并回收内存。
	* 引用计数：记录值被引用的次数。当引用数为0时，垃圾回收程序会清理引用数为0的值的内存。但此法存在循环引用的问题，有可能导致内存永远不会被释放，可以通过把不需要的变量设置为`null`来解除变量的引用。
* 在内存有限的设备上，周期性运行的垃圾回收可能会明显拖慢渲染速度和帧速率，造成性能损失。目前主要根据已分配对象的大小和数量来判断何时运行垃圾回收程序，例如动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。
* 优化内存占用的措施：1. 将不再必要的数据设置为`null`，解除引用，适合全局变量和全局对象的属性。2. 尽可能使用`const`和`let`声明，块级上下文可以更早让垃圾回收程序介入。
* 可能导致内存泄漏的原因：1. 意外声明了全局变量；2. 闭包。
* 减少浏览器执行垃圾回收的次数可以保住因释放内存而损失的性能。可以通过使用对象池来管理一组可回收的对象，在初始化时就静态分配一个大小够用的数组。