### 语法
1. ECMAScript的一切都区分大小写。
2. 标识符第一个字符必须是一个字母、下划线或美元符号，其余字符可以是字母、下划线、美元符号或数字。
3. 标识符建议使用驼峰大小写形式，即第一个单词首字母小写，其余首字母大写。
4. 单行注释`//`，块注释`/* */。
5. ES5中增加严格模式（strict mode），将处理一些不规范写法，对于不安全的活动跑出错误。开启方式是在脚本开头或在函数体开头加上`“use strict”`。
6. 建议语句以分号结尾，有助于开发者压缩代码和提升性能。
7. 建议在控制语句中始终使用花括号包裹。

### 变量
1. ECMAScript的变量是松散类型的，可以保存任何类型的数据。
2. 声明变量的3个关键字：`var`、`const`和`let`。
* `var`关键字：
	* 声明的范围是函数作用域，变量在函数退出时销毁。若省略`var`操作符，将创建一个全局变量，成为`window`对象的属性。
	* 所有使用`var`声明的变量将自动提升到函数作用域顶部。例如，对于`var xxx=100`一句，只提升变量声明`var xxx`至作用域顶部，`xxx=100`留在原位置。
	* 使用`var`可以反复声明同一个变量。
* `let`关键字：
	* 声明的范围是块作用域，块作用域是函数作用域的子集。
	* `let`不允许同一个块作用域中出现冗余声明。
	* 允许嵌套使用相同的标识符，因为JS引擎会记录用于声明的标识符及其所在的块作用域。
	* 使用`let`声明的变量不会提升至作用域顶部，因此存在暂时性死区，暂时性死区的范围在`let`声明之前的执行瞬间。在JS引擎解析代码时，会注意到出现在块后面的`let`声明，但是不能以任何方式引用未声明的变量。
	* 使用`let`在全局作用域中声明的变量不会成为`window`对象的属性。
	* 在for循环中，JS引擎会为每个迭代循环声明一个新的==独立变量实例==，`var`则不会。
* `const`关键字
	* 与`let`基本相同，区别在于必须初始化变量。
	* 修改`const`声明的变量会导致运行时错误。若变量引用的是一个对象，那么修改对象内部的属性是被允许的，因为`const`指向的是变量的引用。
	* 不能使用`const`来声明迭代变量，因为迭代变量会自增，但可以声明一个不会被修改的for循环变量。
3. 有助于提升代码质量的方式：不使用`var`，`const`优先，`let`次之。

### 数据类型
1. 6种简单数据类型/原始类型：`undefined`、`null`、`Boolean`、`Number`、`String`和`Symbol`（ES6新增），1种复杂数据类型：`Object`。

#### typeof操作符
* 用于确定任意变量的数据类型。
* 返回值：`undefined`、`boolean`、`string`、`number`、`object`、`function`、`symbol`。
* `typeof null`返回`"object"`，特殊值`null`被认为是一个对空对象的引用。

#### undefined类型
* 表示变量声明后未初始化。
* 分别对声明未初始化的变量和未声明的变量使用`typeof`操作符，返回的结果都是`“undefined”`，但两者存在根本性差异。因此建议在声明变量的同时初始化，当`typeof`返回`“undefined”`时，就可以知道变量尚未声明。

#### null类型
* 表示一个空对象指针。在定义将来要保存对象值的变量时，建议使用`null`初始化。
* `null == undefined`返回`true`，不过需注意等于（`==`）操作符会为了比较而转换它的操作数。

#### Boolean类型
* 两个字面值：`true`和`false`。
* 所有其他类型的值都可以使用`Boolean()`转型函数转换为布尔值。
![[Boolean()转型函数转换规则.png]]
* if等控制流语句会自动执行其他类型值到布尔值的转换。

#### Number类型
* 可以表示整数和浮点值。
* 整数可以使用十进制、八进制（严格模式下无效）、十六进制字面量表示。
* 浮点值数值中必须包含小数点，且小数点后至少有一个数字。
* 存储浮点值的内存空间是存储整数的两倍，当小数点后没有数字或为0时，数值将转换为整数。
* 浮点值的精确度最高达17位小数，算数计算精确度不如整数。
	* 例如，0.1+0.2!=0.3，这是由于计算机硬件存储数据的形式是二进制，这两个数的二进制都是无限循环的。此外，在现代浏览器中使用浮点数形式的二进制来存储二进制，所以还要将转换后的二进制数转成浮点数形式的二进制。
	* 解决方案：
	1. 使用`toFixed()`四舍五入，只保留小数点后1位，注意`toFixed()`返回值的类型是`String`(字符串) 类型。
	2. 将其转换为整数后在进行运算,运算后再转为对应的小数。
	3. 使用第三方库。
```javascript
// 第一种方案
parseFloat((0.1+0.2).toFixed(1)) === 0.3 // true
// 第二种方案
(0.1*100+0.2*100)/100 === 0.3 // true
```

* 可以表示的最小数值`Number.MIN_VALUE`，5e-324；最大数值`Number.MAX_VALUE`。
* 若计算得到的数值结果超出了可以表示的范围，自动转换为特殊的`Infinity`（正无穷大）值或`-Infinity`（负无穷大）。`isFinite()`函数可以确定一个值是否是有限大。
* `NaN`，一种特殊的数值，表示不是数值。
	1. 0、+0或-0相除会返回`NaN`，而用0除任意非0值会返回`Infinity`或`-Infinity`。
	2. `NaN == NaN`返回`false`，表示不等于包括`NaN`在内的任何值。
	3. `isNaN()`函数接受任意数据类型的值，尝试将它转换为数值，以此判断参数是否为`NaN`。
* 数值转换的3种方式：`Number()`、`parseInt()`和`parseFloat()`。
	1. `Number()`函数：![[Number()函数转换规则.png]]
	2. `parseInt()`函数：
		* 专注于字符串是否包含数值模式。
		* 将从第一个非空格字符开始转换，若第一个字符不是数值字符、加号或减号，立即返回`NaN`，因此空字符串也将返回`NaN`（`Number()`返回0）。
		* 检测持续到遇到字符串末尾，或碰到非数值字符。
		* 接收第二个参数，用于指定进制数。
	 3. `parseFloat()`函数：
		 * 只有第一次出现的小数点是有效的。
		 * 只能解析十进制值。
		 * 如果字符串表示整数，则返回整数。

#### String类型
* 使用双引号（“）、单引号（‘）或反引号表示。
* `toString()`方法：用于将数值、布尔值、对象和字符串值转换为字符串。`null`和`undefined`没有`toString()`方法。用法：`val.toString()`，在对数值调用此方法时，函数内可接收一个底数参数，表示输出数值的指定进制字符串表示。
* `String()`转型函数：若值为`null`或`undefined`，直接返回`"null"`或`“undefined”`；若值有`toString()`方法，则调用该方法返回结果。
* 模版字面量：使用反引号表示，支持字符串插值。用法：在`${}`中插入一个JS表达式，插入的值会使用`toString()`方法强制转型为字符串。

#### Symbol类型
* 符号是原始值，唯一、不可变，用于确保对象属性使用唯一的标识符，不会发生属性冲突。
* `Symbol()`函数：可传入一个字符串参数作为对符号的描述，初始化一个符号。不能与`new`关键字一起作为构造函数使用，避免创建符号包装对象。
	* `Boolean`、`String`或`Number`可以使用构造函数用于初始化包含原始值的包装对象，其`typeof`操作符返回的结果均为`"object"`。
	* `Symbol`可以借助`Object()`函数包装符号对象。
```javascript
let myBoolean = new Boolean();
console.log(typeof myBoolean); // "object“

let mySymbol = Symbol();
let myWrappedSymbol = Object(mySymbol);
console.log(typeof myWrappedSymbol); // "object"
```

* `Symbol.for()`方法：用于在全局符号注册表中创建并重用符号实例，创建时必须传入字符串作为键。
	* 第一次使用某个字符串调用：检查全局符号注册表，若不存在，生成一个新符号实例并添加到注册表。
	* 后续使用相同的字符串调用：检查全局符号注册表，若存在对应的符号，返回该符号实例。
	* 使用`Symbol.for()`方法定义的符号与使用`Symbol()`定义的符号不等同。
* `Symbol.keyFor()`方法：查询全局注册表中符号对应的字符串键。
* 常用内置符号：用于暴露语言内部行为，可以直接访问、重写或模拟这些行为。内置符号实质是全局函数`Symbol`的普通字符串属性，指向一个符号实例。
	* `Symbol.iterator`属性：一个返回对象默认的迭代器的方法，由`for-of`语句使用。

#### Object类型
* 对象是派生其他类型的基类，是一组数据和功能的集合。通过`new`操作符后跟对象类型的名称来创建对象实例。
* 所有对象实例都有的属性和方法：
	* `constructor`：用于创建当前对象。
	* `hasOwnProperty(propertyName)`：判断当前对象实例上是否存在给定的属性，需传入字符串或符号。
	* `isPrototypeOf(object)`：判断当前对象是否为另一个对象的原型。
	* `toString()`：返回对象的字符串表示。
	* `valueOf()`：返回对象对应的字符串、数值或布尔值表示。

### 操作符
#### 一元操作符
* 递增/减，一元加/减。

#### 位操作符
* 用于数值的底层操作。先把值转换为32位整数，再进行位操作，再把结果转换为64位。
* 按位非（`~`）、按位与（`&`）、按位或（`|`）、按位异或（`^`）、左移（`<<`）、有符号右移（`>>`）和无符号右移（`>>>`）。

#### 布尔操作符
* 逻辑非（`!`）、逻辑与（`&&`）和逻辑或（`||`）。
* 逻辑非：空字符串、数值0、`null`、`NaN`、`undefined`返回`true`，其余返回`false`。
* 逻辑与：短路操作符。
	* 若第一个操作数是对象，返回第二个操作数。
	* 若第二个操作数是对象，第一个操作数求值为`true`时返回第二个操作数。
	* 若两个操作数都是对象，返回第二个操作数。
	* 有一个操作数为`null`/`NaN`/`undefined`，返回`null`/`NaN`/`undefined`。
* 逻辑或：
	* 若第一个操作数是对象，返回第一个操作数。
	* 第一个操作数求值为`false`时，返回第二个操作数。
	* 若两个操作数都是对象，返回第一个操作数。
	* 两个操作数都为`null`/`NaN`/`undefined`，返回`null`/`NaN`/`undefined`。

#### 乘性操作符
* 乘法（`*`）、除法（`/`）和取模（`%`）。
* 乘法：
	* 不能表示乘积，返回`Infinity`或`-Infinity`。
	* 任意操作数为`NaN`，返回`NaN`。
	* `Infinity`乘以0，返回`NaN`。
	* `Infinity`乘以非0的有限数值，根据第二个操作数返回`Infinity`或`-Infinity`。
	* `Infinity`乘以`Infinity`，返回`Infinity`。
	* 有不是数值的操作符，先使用`Number()`转换为数值，再应用上述规则。
* 除法：
	* 不能表示商，返回`Infinity`或`-Infinity`。
	* 任意操作数为`NaN`，返回`NaN`。
	* `Infinity`除以`Infinity`，返回`NaN`。
	* 0除以0，返回`NaN`。
	* 非0的有限数值除以0，根据第一个操作数返回`Infinity`或`-Infinity`。
	* `Infinity`除以任意数值，根据第二个操作数返回`Infinity`或`-Infinity`。
	* 有不是数值的操作符，先使用`Number()`转换为数值，再应用上述规则。
* 取模：
	* 被除数是无限值，除数是有限值，返回`NaN`。
	* 被除数是有限值，除数是0，返回`NaN`。
	* `Infinity`除以`Infinity`，返回`NaN`。
	* 被除数是有限值，除数是无限值，返回被除数。
	* 被除数是0，除数不是0，返回0.
	* 有不是数值的操作符，先使用`Number()`转换为数值，再应用上述规则。

#### 指数操作符
* 指数（`**`），与`Math.pow()`方法作用相同。

#### 加性操作符
* 加法（`+`）、减法（`-`）。
* 加法：
	* 两个操作符都是数值时：
		* 任意操作数为`NaN`，返回`NaN`。
		* `Infinity`加`Infinity`，返回`Infinity`。
		* `-Infinity`加`-Infinity`，返回`-Infinity`。
		* `Infinity`加`-Infinity`，返回`NaN`。
		* +0加+0，返回+0。
		* +0加-0，返回+0。
		* -0加-0，返回-0。
	* 有一个操作数是字符串：
		* 两个操作数都是字符串，第二个字符串拼接到第一个字符串后面。
		* 其中一个操作数是字符串，将另一个操作数转换为字符串后进行拼接。
	* 任一操作数是对象、数值或布尔值：调用`toString()`方法获取字符串。
	* `undefined`和`null`：调用`String()`函数，转换为`"undefined"`和`"null"`。
* 减法：
	* 两个操作符都是数值时：
		* 任意操作数为`NaN`，返回`NaN`。
		* `Infinity`减`Infinity`，返回`NaN`。
		* `-Infinity`减`-Infinity`，返回`NaN`。
		* `Infinity`减`-Infinity`，返回`Infinity`。
		* `-Infinity`减`Infinity`，返回`-Infinity`。
		* +0减+0，返回+0。
		* +0减-0，返回-0。
		* -0减-0，返回+0。
	* 有一个操作数是字符串、布尔值、`null`或`undefined`：使用`Number()`转换为数值，再执行上述规则。
	* 任一操作数是对象：调用`valueOf()`方法获取数值，如果没有`valueOf()`方法，调用`toString()`方法，再转换为数值。

#### 关系操作符
* 小于（`<`）、大于（`>`）、小于等于（`<=`）、大于等于（`>=`），返回布尔值。
	* 操作数都是数值，执行数值比较。
	* 操作数都是字符串，逐个比较字符编码。大写字母的字符编码小于小写字母。
	* 任一操作数为数值，将另一个操作数转换为数值。
	* 任一操作数是对象，调用`valueOf()`方法获取数值，如果没有`valueOf()`方法，调用`toString()`方法，再转换为数值。
	* 任一操作数是布尔值，转换为数值。

#### 相等操作符
* 等于（`==`）和不等于（`!=`），全等（`===`）和不全等（`!==`）。
* 等于和不等于操作符会进行强制类型转换。
	* 任一操作数是布尔值，转换为数值再比较。
	* 一个操作数是字符串，一个操作数是数值，将字符串转换为数值再比较。
	* 一个操作数是对象，另一个不是，调用对象的`valueOf()`方法取得原始值再比较。
	* `null`和`undefined`相等。
	* `null`和`undefined`不能转换为其他类型再比较。
	* 任一操作数为`NaN`，相等操作返回`false`，不相等操作返回`true`。
	* 两个操作数都是对象，比较是否指向同一个对象。
* 全等和不全等操作符不会进行强制类型转换，数据类型不同时返回`false`。
	* `null`和`undefined`不全等。

#### 条件、赋值、逗号操作符
* 条件（`? :`）、赋值（`=`）、逗号（`,`）。

### 流控制语句
* `if`、`do-while`、`while`、`for`、`for-in`枚举对象中的非符号属性、`for-of`遍历可迭代对象的元素、`break`和`continue`、`with`、`switch`。