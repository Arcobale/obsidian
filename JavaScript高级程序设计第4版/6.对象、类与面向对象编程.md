## 对象
---
* 对象是一组属性的无序集合，对象的每个属性和方法由一个名称来标识，并映射到一个值。
* 属性的特征使用一些内部特性来描述，使用两个中括号将特性名称括起来。
* 属性分为两种：数据属性和访问器属性。
	* 数据属性：包含数据值。
		* `[[configurable]]`：表示属性是否可以删除并重新定义、是否可以修改其特性、是否可以把它修改为访问器属性。默认为`true`。
		* `[[enumerable]]`：表示属性是否可以枚举。默认为`true`。
		* `[[writable]]`：表示属性的值是否可以被修改。默认为`true`。
		* `[[value]]`：包含属性实际的值。默认为`undefined`。
	* 访问器属性：不包含数据值。不能直接定义，需要使用`Object.defineProperty()`。
		* `[[configurable]]`：表示属性是否可以删除并重新定义、是否可以修改其特性、是否可以把它修改为数据属性。默认为`true`。
		* `[[enumerable]]`：表示属性是否可以枚举。默认为`true`。
		* `[[get]]`：获取函数，在读取属性时调用，返回一个有效值。默认为`undefined`。
		* `[[set]]`：设置函数，在写入属性时调用，传入新值。默认为`undefined`。
* `Object.defineProperty()`：用于修改属性的默认特性。接收3个参数：对象、属性名、描述符对象。
	* 调用后如果不指定`configurable`、`enumerable`和`writable`的值，则默认为`false`。
	* 非严格模式下尝试执行非法操作会被忽略，严格模式下会抛出错误。
* `Object.defineProperties()`：通过多个描述符一次性定义多个属性。
* `Object.getOwnPropertyDescriptor()`：取得指定属性的属性描述符。接收2个参数：对象和属性名，返回一个描述符对象。
* `Object.getOwnPropertyDescriptors()`：取得对象上的所有属性描述符，返回一个对象。
* `Object.assign(dest, src)`：将源对象`src`所有的可枚举和自有属性一起复制到目标对象`dest`上。
	* 接收一个目标对象和一个或多个源对象，使用源对象上的`[[get]]`取得属性的值，再使用目标对象上的`[[set]]`设置属性的值。
	* 对于相同的属性，会使用最后一个复制的值。
	* 该操作是浅复制，意味着只复制对象的引用，不能转移获取函数和设置函数。
	* 抛出错误后无法回滚已经完成的修改。
* `Object.is()`：考虑了全等操作符的边界情形。
```javascript
Object.is(+0, -0) === false
Object.is(+0, 0) === true
Object.is(-0, 0) === false
Object.is(NaN, NaN) === true
```
* 定义和操作对象的语法糖（ES6新增）：
	* 属性值简写：属性名和变量名相同时，只需要使用变量名。
	* 可计算属性：在使用对象字面量创建对象时，可以使用中括号包围的对象属性键表示一个JS表达式，在对象实例化时再求值。
	* 简写方法名：原来的`方法名：function()`写法可以简写为`方法名()`。
* 对象解构：使用与对象匹配的结构来实现对象属性赋值。
	* 在类似字面量的结构中声明多个变量，同时执行多个赋值操作，赋值均为浅复制。
	* 当变量和属性名相同时，可以简写。
	* 如果引用的属性不存在，变量值就是`undefined`。
	* 可以为变量定义默认值，适用于引用的属性不存在的情况。
	* 在对象解构时，原始值也会被当成对象，可以解构出`String`类型的`length`属性或`constructor`属性等。`null`和`undefined`不能被解构。
	* 给事先声明的变量解构赋值时，需要将赋值表达式包裹在一对括号中。
	* 嵌套解构：解构赋值可以使用嵌套解构，获取深层属性。当源对象或目标对象的外层属性没有定义时，无法使用嵌套解构。
	* 部分解构：抛出错误后无法回滚已经完成的赋值，只能完成一部分赋值。
	* 参数上下文匹配：在函数声明时可以将传入的对象解构赋值，声明局部变量。

## 对象的创建
---
### 工厂模式
* 工厂模式是一种用于创建特定对象的设计模式，可以解决创建多个类似对象的问题，但是无法知道新创建的对象是什么类型。

### 构造函数模式
* 构造函数可以自定义，以函数的形式为自己的对象类型定义属性和方法。
* 构造函数与工厂函数的区别：1.没有显示创建对象；2.属性和方法赋值给了`this`；3.没有`return`。
* 构造函数的函数名首字母需要大写，用以和普通函数作区分。
* 构造函数使用`new`操作符创建对象实例的过程：
	1. 在内存中创建一个新对象。
	2. 新对象内部的`[[prototype]]`特性被赋值为构造函数的`prototype`属性。
	3. 构造函数内部的`this`被赋值为新对象。
	4. 执行构造函数代码，为新对象添加属性和方法。
	5. 若构造函数返回非空对象，则返回该对象；否则返回创建的新对象。
* 创建的对象实例有一个`constructor`属性指向构造函数，用于标识对象类型。但`instanceof`操作符被认为是更可靠的方式。
* 构造函数也可以写为赋值给变量的函数表达式。
* 构造函数也是函数，区别在于调用方式不同，只要使用`new`操作符调用就是构造函数。构造函数当作为普通函数调用时，没有明确设置`this`值，此时`this`指向`Global`对象。
* 构造函数的局限：构造函数定义的方法在每个对象实例上都要创建一遍，会重复定义相同逻辑的函数。初步解决方法是将函数定义在构造函数外部，在构造函数内部定义一个属性指向外部函数，达到共享方法的目的。但这样会将全局作用域搞乱，自定义类型的代码不能聚集在一起。

### 原型模式
#### 理解原型
* 每个函数都有自己的`prototype`属性，指向原型对象，是通过调用构造函数创建的对象实例的原型。在原型对象上定义的属性和方法由所有实例共享。
* 原型对象自动获得名为`constructor`的属性，指向关联的构造函数，即`Person.prototype.constuctor === Person`。
* 使用构造函数创建的对象实例内部的隐藏特性`[[prototype]]`被赋值为构造函数的原型对象，一些浏览器会在对象上暴露`__proto__`属性，访问到对象的原型。
* 实例与构造函数原型间有直接联系，而与构造函数之间没有。
* 正常的原型链会终止于`Object`的原型对象，`Object`原型的原型是`null`。
* 构造函数、构造函数的原型和实例是3个完全不同的对象。
* 同一个构造函数创建的实例共享同一个实例对象。
* `isPrototypeOf()`：用于确定两个对象间的原型关系。
* `Object.getPrototypeOf()`：返回传入对象的内部隐藏特性`[[prototype]]`的值。
* `Object.setPrototypeOf()`：向实例的私有特性写入新值，重写对象的原型继承关系。但这样会严重影响代码性能。
* `Object.create()`：创建一个新对象，避免了使用`Object.setPrototypeOf()`造成的性能下降。

#### 原型层级
* 在通过对象访问属性时，会按属性名搜索，开始于对象实例本身，沿着指针进入原型对象，一旦找到指定属性，就返回对应的值。给对象实例添加原型对象上的同名属性，会屏蔽对原型对象上同名属性的访问。只能使用`delete`完全删除实例上的属性，才能使标识符解析过程继续搜索原型对象。
* `hasOwnProperty()`：用于确定某个属性是否为实例属性，当在实例上时返回`true`。

#### 原型和in操作符
* 单独使用`in`操作符：可以通过对象访问指定属性时返回`true`，无论在实例还是在原型上。
* `hasPrototypeProperty()`：用于确定某个属性是否为原型属性，当在原型上时返回`true`。
* for-in循环中使用`in`操作符：可以通过对象访问且可枚举的属性都会返回，包括实例属性和原型属性。
* `Object.keys()`：返回对象上所有可枚举的实例属性。
* `Object.getOwnPropertyNames()`：返回所有实例属性，无论是否可枚举。包括不可枚举的`constructor`属性。
* `Object.getOwnPropertySymbols()`：返回所有键为字符的实例属性。
* for-in循环和`Object.keys()`的枚举顺序不确定；`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Object.assign()`的枚举顺序是确定的，先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。

### 对象迭代
* `Object.values()`返回对象值的数组，`Object.entries()`返回对象键值对的数组。非字符串属性会被转换为字符串输出，执行浅复制，忽略符号属性。
#### 原型定义语法
* 另一种原型的定义方法：使用对象字面量方式重写原型。但这样会使得原型的`constructor`属性改变，指向`Object`，不再指向原来的构造函数。此时`instanceof`仍可以识别正确引用类型，`constructor`属性失效。
* 对于`constructor`属性改变指向的问题，可以通过在定义对象字面量时手动写入`constructor`的指向，但注意需使用`Object.defineProperty()`定义`constructor`属性的`[[enumerable]]`为`false`，将其修改为不可枚举。

#### 原型的动态性
* 当实例已经存在，任何对原型的修改也会在实例上反映出来，这主要是由于实例与原型间的链接就是简单的指针，而不是保存的副本。
* 重写原型和在原型上添加属性和方法是两回事。重写原型会切断最初的原型对象与构造函数的联系，实例引用的仍是最初的原型对象。

#### 原生对象的原型
* 原生引用类型的构造函数（`Object`、`Array`、`String`等）都在原型上定义了实例方法。通过原生对象的原型可以取得默认方法的引用，也可以自定义新的方法，当前环境下所有该类型的原生对象可以使用此方法。

#### 原型的局限性
* 弱化了向构造函数传递初始化参数的能力，所有实例默认取得相同的属性值。
* 原型模式创建的不同实例间共享相同的属性和方法，对一个实例的包含引用值的属性的修改会影响另一个实例，不同的实例没有属于自己的属性副本。因此，通常不单独使用原型模式。

## 继承
---
### 原型链
* 原型链的基本思想是通过原型继承多个引用类型的属性和方法。如果原型是另一个类型的实例，那么这个原型本身有一个内部指针指向另一个原型，依次类推，在实例和原型之间构造了一条原型链。
* 子类的原型赋值为父类的实例对象，实现了对父类的继承。![[Pasted image 20230603175650.png]]
* 实现原型链继承的关键是子类将其默认原型替换成了一个新对象，即父类的实例。因此，子类的实例可以从父类实例中继承属性和方法，还可以访问父类的原型。
* 子类原型对象在被重写为父类实例时，其`constructor`属性指向父类，所以子类实例的`constructor`属性也指向父类。同时，父类构造函数内定义的属性成为子类原型对象上的实例属性。
* 子类在需要覆盖父类方法或增加父类没有的方法时，必须在子类原型重写后再添加到子类原型上，需要注意的是不能使用对象字面量方式，因为会破环之前的原型链。
* 原型链的问题：1.原型中包含的引用值会在实例间共享。这是因为子类原型在重写时，指向的是同一个父类实例。2.子类创建实例时不能给父类的构造函数传参。因此原型链不会单独使用。

### 盗用构造函数
* 思路：在子类构造函数中调用父类构造函数，使用`apply()`或`call()`方法以创建的对象为上下文执行构造函数。
* 该方法可以在子类构造函数中向父类构造函数传参，然后再给子类实例添加额外的属性。
* 盗用构造函数的问题：1.必须在构造函数中定义方法，函数不能重用。2.子类不能访问父类原型上的方法。因此该法不会单独使用。

### 组合继承
* 思路：综合原型链和盗用构造函数。使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。使方法定义在原型上以实现重用，并让每个实例拥有自己的属性。

### 原型式继承
* `Object.create()`：即使不自定义类型也可以通过原型实现对象之间的信息共享。
* 实现思路：创建一个临时构造函数，将传入的对象赋值给构造函数的原型，返回临时类型的实例。
```javascript
function myObjectCreate(obj) {
	function F() {}
	F.prototype = obj;
	return new F();
}
```

### 寄生式继承
* 与原型式继承类似，创建一个实现继承的函数，以某种方式增强对象，返回这个对象。适合主要关注对象，而不在乎类型和构造函数的场景。

### 寄生式组合继承
* 组合继承的效率问题：父类构造函数在创建子类原型时和子类构造函数时调用了两次，导致两组相同的属性出现在子类的实例和原型对象上。
* 解决思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本，将返回的副本设置`constructor`属性，指回子类，最后将副本赋值给子类原型。
* 只调用了一次父类构造函数，避免子类原型上出现不必要的属性，是引用类型继承的最佳模式。

## 类
---
### 类的定义
* ES6新增了`class`关键字，具备正式定义类的能力。
* 定义类的方式：类声明和类表达式。类表达式的名称可选，可以在赋值后通过`name`属性获取类表达式的名称字符串。
* 类表达式和函数表达式在被求值前都不能被引用。函数声明可以提升，但类定义不能。函数受函数作用域限制，类受块作用域限制。
* 类的构成：构造函数、实例方法、获取和设置函数、静态类方法。

### 类构造函数
* 类构造函数可以不定义，相当于定义为空函数。
* 使用`new`操作符创建类的实例时，调用类构造函数，其构造函数执行流程与调用普通构造函数相同。
* 创建实例时，如果不传入参数，类名的括号可选。
* 若类构造函数返回非空对象，则该对象无法通过`instanceof`操作符检测出和该类有关联，因为其原型指针未改变。
* 类构造函数与普通构造函数的区别：调用类构造函数必须使用`new`操作符，否则抛出错误；普通构造函数在不使用`new`调用时，`this`指向`Global`对象。
* 类构造函数在类实例化后可以在实例上被引用，成为普通的实例方法。
* 使用`typeof`操作符检测类标识符的结果是`function`，说明类是一个函数。
* 类标识符有`prototype`属性，该原型也有`constructor`属性指向自身。
* 在使用`new`调用时，类本身被当成构造函数，而类中定义的`constructor`方法不会被当成构造函数。如果在实例化时使用类构造函数创建，则实例会通过`instanceof`操作符检测出来与类构造函数有关联。
* 类可以作为参数传递或立即实例化。

### 实例、原型和类成员
* 实例成员：在类构造函数中添加实例属性或方法，实例间不共享其中定义的引用值。
* 原型方法与访问器：在类块中定义的方法称为原型方法，在实例间可以共享这些方法。原始值或对象不能直接定义在类块中。类定义支持获取和设置访问器。
* 静态类方法：使用`static`关键字作为函数前缀，用于执行不特定于实例的操作，不要求存在类的实例。静态类方法中的`this`指向类本身。
* 非函数原型和类成员：在类定义外部手动添加类和其原型上的数据成员。
* 迭代器与生成器方法：支持在类和其原型上定义生成器和迭代器方法。可以为类添加默认迭代器，使类实例变为可迭代对象。

### 继承
* 类继承机制的原理仍是原型链。
* 使用`extends`关键字实现对类或普通构造函数的单继承。
* 派生类通过原型链访问到类，`this`指向调用相应方法的实例或类。
* 派生类使用`super`关键字引用它们的原型，只能在派生类中使用，也就是只能跟`extends`联用。
	* `super`不能单独引用。
	* 在派生类构造函数中调用`super()`：调用父类构造函数，将返回的实例赋值给`this`。
		* 不能在调用`super()`前引用`this`。
		* 如果需要传递参数，可以在`super()`中传入。
		* 如果派生类构造函数未定义，则会自动调用`super()`并传入所有传给派生类的参数。
		* 如果派生类构造函数被显式定义，则要么调用`super()`，要么返回一个对象。
	* 在实例方法和静态方法中调用`super`：调用继承的类上定义的对应方法。
	* 类构造函数和静态方法中包含内部特性`[[HomeObject]]`，指向定义该方法的对象。`super`始终被定义为`[[HomeObject]]`的原型。
* 抽象基类：可供其他类继承，但本身不会被实例化。
	* `new.target`中保存了通过`new`关键字调用的类或函数，在实例化时检测`new.target`是否为抽象基类，抛出错误，阻止对抽象基类的实例化。
	* 当要求派生类上必须定义某个方法时，可以在抽象基类构造函数中检查。因为原型方法的定义先于构造函数的定义，当调用到抽象基类的构造函数时，派生类原型方法已经存在，因此可以通过`this`关键字检查相应的方法。
* 内置的引用类型可以通过`extends`关键字进行继承，默认返回的实例类型与派生类类型一致。可以通过`Symbol.species`访问器覆盖默认行为。